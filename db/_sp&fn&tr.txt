DB에서의 프로그래밍 제어문
 - 일반 쿼리에서는 사용할 수 없고, 프로시저나 함수 내부에서 사용됨

1. 변수
 - 프로시저 내에서 변수를 따로 선언하고 값을 넣어 사용할 수 있음
 - 선언 및 초기화
declare 변수명 자료형[ default 초기값]; -- 변수의 초기화도 선언과 함께 할 수 있음
 - 값설정1 : default 명령을 이용하여 변수 선언 시 초기화 시킬 수 있음
 - 값설정2 : set 변수명 = 값;
 - 값설정3 : select 컬럼명 into 변수명 from 테이블명[ where 조건 등...];
 	--	테이블에 있는 특정 컬럼의 값을 변수에 저장할 수도 있음
 - 변수명은 자바와 같은 방식으로 짓는 것이 좋음

2. 분기문
 - 조건에 따라 특정 영역의 실행문을 실행시키는 제어문

 2-1. if문
  - 가장 많이 사용되는 분기문으로 조건의 참, 거짓에 따라 실행할 실행문이 달라짐
  - 실행문이 두 명령 이상일 경우 begin과 end로 묶어 처리해야 함
  - 문법
 if 조건1 them
 begin
 	실행문1;
 end;
[
elseif 조건2 then
begin
	실행문2;
end;
...
elseif 조건n then
begin
	실행문n;
end;
else
begin
	실행문;
end;
] 
 end if;

 2-2. case 문
  - 자바의 switch문과 비슷하나, 조건을 입력할 수 있음
  - 문법
case
when 조건1 then
	실행문1;
when 조건2 then
	실행문2;
...
when 조건n then
	실행문n;
else
	모든 조건이 거짓일 때 실행할 실행문;
end case;

3. 반복문
 - 조건을 주어 조건이 참인 동안 지정한 실행문을 반복하여 실행시키는 제어문
 - 레이블은 생략가능하지만, iterater와 leave 명령을 사용하려면 필수임
 - iterate 명령
 	자바의 continue와 비슷한 기능을 함
	레이블을 지정한 후 iterate를 실행하면 지정된 레이블로 이동함
 - leave 명령
 	자바의 break와 비슷한 기능을 함
	레이블을 지정한 후 leave를 실행하면 지정된 레이블의 반복문을 빠져나감

3-1. while 문
 - 자바의 while문과 동일하게 동작
 - 문법
[레이블:]while (조건) do
	실행문;
end while;

3-2. loop 문
 - 기본적으로 무한루프이며 조건을 loop문 안에서 if를 이용하여 입력하고, leave 명령을 이용해 반복문을 빠져나옴
 - 문법
레이블:loop
	실행문;
	if 루프를 끝낼 조건 then
		leave 레이블;
	end if;
end loop;

3-3. repeat-until 문
 - 문법
repeat
	실행문;
	until 반복을 끝낼 조건 -- 조건이 참이면 반복문 종료(';' 없음)
	-- until 절은 반드시 repeat 문의 가장 아래에 위치시켜야 함
end repeat;

스토어드 프로시저(Stored Procedure)
 - DB의 객체들 중 하나로 저장 프로시저라고도 함
 - DBMS에서 제공하는 프로그래밍 기능으로 일반적인 프로그래밍과는 다르지만, DBMS내에서 사용됨
 - 스토어드 프로시저는 쿼리문들의 집합으로, 어떠한 동작을 일괄처리하기 위한 용도로 사용됨
 - 또는 자주 사용되는 일반적인 쿼리를 사용 시 마다 다시 입력하여 사용하기 보다는 이것을 모듈화 시켜서 필요할 때 마다 호출만 하면 되도록 만든 것을 의미

 - 사이트 제작 시 스토어드 프로시저를 사용했을 때 생기는 장점
 	자바에서는 스토어드 프로시저를 호출만 하고, 실제 실행은 DB에서 하므로 웹서버가 아닌 DB서버에서 작업이 이루어져 웹 서버의 부담을 덜어주어 사이트 전반적인 속도가 향상됨
	쿼리의 제작을 자바가 아닌 DB에서 하므로 보안상 뛰어남

 - 단점
 	프로젝트 초기에 스토어드 프로시저를 먼저 생성해야 하기 때문에 초반 작업이 늘어남
	필요한 기능을 가진 스토어드 프로시저를 만들기 위해서는 미리 기능에 대한 이해가 있어야 함

 - 스토어드 프로시저 생성법
drop procedure if exists 프로시저명;
-- 프로시저 생성이 아닌 삭제 명령으로 기존의 동명의 프로시저가 있으면 삭제 후 재생성하기 위한 명령

delimiter $$
-- 명령의 종료 표시를 ';'이 아닌 '$$'로 임시 변경한다는 의미
create procedure 프로시저명([in 또는 out 매개변수(들)])
-- 지정한 이름의 프로시저를 현 DB에 생성하겠다는 의미(프로시저명은 보통 'sp_'로 시작함)
-- 매개변수는 없을 수도 있으며, 있는 경우 값을 받아오는 매개변수(in)와 값을 내보내는 매개변수(out)로 나뉨
begin
-- 프로시저의 시작을 의미
	프로시저의 내용으로 쿼리와 프로그래밍이 들어갈 영역이며 여러 개의 쿼리를 사용해도 됨
end $$
-- 프로시저의 종료를 의미($$로 명령의 종료를 의미)
delimiter ;
-- 명령의 종료 표시를 다시 ';'으로 되돌린다는 의미

 - 실행법 : call 프로시저명([인수(들)]);	--	call = MySQL 전용 명령어
 - 삭제법 : drop procedure 프로시저명;


스토어드 함수(Stored Function)
 - 사용자가 직접 만들어서 사용하는 함수로 그냥 함수나 사용자 정의 함수라고도 함
 - 스토어드 프로시저에 비해 사용빈도가 낮은 편으로 사용여부는 상황에 맞게 판단하면 됨
 - 함수는 무조건 리턴값이 존재해야 함
 - 매개변수는 in과 out의 구분없이 무조건 in에 해당하는 값을 받아오는 역할을 함
 - 스토어드 프로시저에서는 select문을 사용할 수 있지만 함수에서는 불가
	select문의 실형결과는 여러 값의 집합으로 리턴할 수 없기 때문에 함수에서는 사용불가
	단, select ... into 문은 집합을 리턴하는 것이 아니므로 사용가능
 - 스토어드 프로시저는 여러 쿼리문의 실행이나 계산등의 작업에 사용되지만, 함수는 어떤 계산을 통해 하나의 값을 받아오는 용도로만 사용됨
 - 스토어드 프로시저나 일반 쿼리문에서도 함수를 호출할 수 있음

 - 생성법
 set global log_bin_trust_function_creators = 1;
 -- 함수 생성을 위해 현재 로그인한 사용자에게 함수 생성 권한을 주는 명령

 drop function if exists 함수명;
 -- 함수 생성이 아닌 삭제 명령으로 함수를 수정하지 않고 삭제 후 재생성하기 위한 명령
delimiter $$
-- 명령의 종료 표시를 ';'이 아닌 '$$'로 임시 변경한다는 의미
 create function 함수명([매개변수(들)]) returns 리턴할 데이터의 자료형
 begin
-- 함수의 시작을 의미
	함수의 내용;
	return 리턴값
end $$
-- 프로시저의 종료를 의미($$로 명령의 종료를 의미)
delimiter ;
-- 명령의 종료 표시를 다시 ';'으로 되돌린다는 의미

 - 실행법 : select 함수명 ([매개변수(들)]);
 - 삭제법 : drop function 함수명;




set global log_bin_trust_function_creators = 1;
drop function if exists 함수명;
delimiter $$
create function 함수명([매개변수(들)]) returns 자료형
begin

	return
end $$
delimiter ;




 트리거(trigger)
  - 특정 테이블에서 무슨 일이 발생하면 자동으로 지정해 놓은 작업이 실행되게 하는 기능
  	테이블에 입력, 수정, 삭제 중 하나가 발생하면 지정한 트리거에 의해 특정 작업이 실행됨
 - 트리거는 특정 테이블에 부착(attach)되는 SQL 프로그램 코드라고 생각하면 됨
 	뷰(view)에는 트리거를 장착할 수 없음(장착 가능한 DBMS도 있음)
 - 프로시저와 비슷한 방식으로 생성하나 프로시저와는 다르게 독립적으로 실행시킬 수 없고, 오직 해당 테이블에 특정 이벤트가 발생할 경우에만 실행됨(매개변수도 사용할 수 없음)
 - DBMS의 기능들 중 메모리를 많이 차지하는 기능으로 꼭 필요한 기능이 아니면, 프로시저 등으로 돌려서 작업하는 것이 좋음
 - 종류 : after와 before로 특정 작업 전후로 트리거에서 지정한 작업이 동작하게 됨

 - 생성법 :
 drop trigger if exists 트리거명명;
 -- 트리거 생성이 아닌 삭제 명령으로 트리거를 수정하지 않고 삭제 후 재생성하기 위한 명령
delimiter $$
create trigger 트리거명 {after | before} {insert | update | delete} on 테이블명 for each row
 begin
	트리거의 내용;
end $$
delimiter ;

 - 삭제 : drop trigger 트리거명;
 - 트리거의 내용에는 해당 테이블에 대한 쿼리는 사용할 수 없음
 - 가장 많이 사용되는 형태는 백업으로 변경 또는 삭제 전의 데이터를 다른 테이블로 백업받는 형식으로 사용됨
 	기존의 데이터는 'old'라는 객체를 통해 받아올 수 있음(update와 delete일 때 사용가능)
		- 예) old.컬럼명 => 변경 또는 삭제 전의 컬럼에 들어있던 값
		새로운 데이터는 'new'라는 객체를 통해 받아올 수 있음(update와 insert일 때 사용가능)
		- 예) new.컬럼명 => 변경 또는 삽입된 컬럼에 들어있는 새로운 값
 - 트리거 사용시 반드시 내용을 문서화하여 기록해둬야 함(유지 보수시 필요)





