조인(join)
- select 쿼리에서 사용하는 기능으로 두 개 이상의 테이블을 서로 묶어서 하나의 결과 집합으로 만들어 내는 기능
- 조인을 사용하면 속도가 느리지만 사용하지 않고 처리하려면 더 느림으로 반드시 숙지해야 함

1. Inner join
 - 내부 조인이라고도 하며 가장 많이 사용되는 조인으로 일반적으로 조인이라 하면 inner join을 의미함
 - 문법
select 가져올 컬럼(들) from 테이블1 inner join 테이블2 on 테이블1과 2의 결합조건;
또는
select 가져올 컬럼(들) from 테이블1, 테이블2 where 테이블1과 2의 결합조건;

 - 가져올 컬럼이나 조건 등에서 사용할 컬럼들의 이름이 두 테이블 모두에 있을 수도 있으므로 테이블명.컬러명의 방식으로 작업해야 하지만
 	길 경우 번거로우므로 테이블 이름에 alias(별칭)를 붙여 사용하는 것이 일반적임

 - 결합조건에 사용될 컬럼들은 보통 관계를 맺지 않은 상태에도 가능하나 일반적으로 관계를 맺은 PK 와 FK를 결합조건으로 사용함
 
 - 3개 이상의 테이블 조인
select 가져올 컬럼(들) from 테이블1 inner join 테이블2 on 테이블1과 2의 결합조건 inner join 테이블 3 on
테이블3과 1 또는 2의 결합조건;
또는
select 가져올 컬럼(들) from 테이블1, 테이블2 테이블 3 where 테이블1과 2의 결합조건 and 테이블3과 1또는 2의 결합조건;

2. Outer Join
 - 외부 조인이라고도 하며 조인의 조건에 만족하지 않는 레코드들도 포함시키는 조인 방법
 - 문법
select 가져올 컬럼(들) from 테이블1 <left | right> [outer] join 테이블2 on 테이블1과 2의 결합조건;

 - left를 사용하면 왼쪽의 테이블인 테이블1의 레코드는 모두 출력하고 테이블2는 결합조건에 맞는 레코드만 출력
 - right를 사용하면 오른쪽의 테이블인 테이블2의 레코드는 모두 출력하고 테이블1는 결합조건에 맞는 레코드만 출력
 - outer 명령은 생략이 가능하여 outer join을 left join이나 right join으로 부르기도 함

 3. Cross Join
  - 조건없이 두 테이블의 모든 레코드를 출력하는 조인 방법
  - 문법
 select 가져올 컬럼(들) from 테이블1 cross join 테이블2;
 또는
 select 가져올 컬럼(들) from 테이블1 테이블2;
  - 조건이 없으므로 on이나 where절이 따로 필요없음
  - 실제로는 거의 사용하지 않음

  4. Union 연산자
   - 조인은 아니고, 여러 쿼리의 결과를 합쳐서 하나의 결과로 출력하는 기능
   - 문법
  select 쿼리1
  union [all]
  select 쿼리2
  union
  select 쿼리n;
	- 사용 시 각 쿼리에서 추출하는 컬럼의 개수가 같아야 함(자료형은 달라도 됨)
	- union 없이 작업할 경우 쿼리의 개수만큼 ResultSet이 필요한 상황에서 하나의 ResultSet만으로 처리가능
	- 각 쿼리의 결과를 따로 사용해야 할 경우 쿼리들 사이에 'select '-', ... ,'-'' 등의 구분용 쿼리를 사용할 수도 있음
	-예)
select 칼럼1, ... , 컬럼n from 테이블1
union
select '-', ... ,'-'
nunion
select 컬럼1, ... , 컬럼n from 테이블2

5. in, Not In 연산자
 - 특정 컬럼의 값이 지정한 목록에 있는지 없는지에 따라 출력할 레코드를 선택하는 기능
 - 문법
select 컬럼(들) from 테이블 where 컬럼명 in (비교값1, 비교값2, ... , 비교값n);
	--	컬럼의 값들 중 목록에 동일한 값이 있으면 출력
select 컬럼(들) from 테이블 where 컬럼명 not in (비교값1, 비교값2, ... , 비교값n);
	--	컬럼의 값들 중 목록에 동일한 값이 없으면 출력
 
  - 괄호 안에는 비교할 값들을 쉼표로 구분하여 넣거나 서브쿼리를 이용하여 select 해올 수 있음
  - 서브쿼리 문법
 select 컬럼(들) from 테이블 where 컬럼명 in (select 비교할 컬럼 from 테이블[ where 조건]);
	-- 컬럼의 값들 중 서브쿼리로 추출한 값 목록에 동일한 값이 있으면 출력
 select 컬럼(들) from 테이블 where 컬럼명 not in (select 비교할 컬럼 from 테이블[ where 조건]);
	-- 컬럼의 값들 중 서브쿼리로 추출한 값 목록에 동일한 값이 없으면 출력

※ 서브쿼리
 - 괄호로 묶어서 사용하며 항상 select문으로 서브쿼리를 작성해야 함
 - 사용되는 쿼리
 	select문에서는 어디서든 사용가능
	insert문에서는 values 절에서 사용가능
	update문에서는 set 절에서 사용가능
 - join 보다도 속도가 느리므로 사용 시 주의해야 함

 인덱스(Index)
  - 검색속도 향상을 위해 사용하는 기능으로 검색이 이루어지는 특정 컬럼에 장착하여 사용함

  - 장점
	검색속도가 빨라짐(단, 항상 빨라지는 것은 아님)
	속도가 빨라지므로 쿼리의 실행시간이 줄어들어 전체 시스템(프로그램 or 사이트)의 성능 향상

 - 단점
 	인덱스가 DB의 공간을 일정부분 차지하게 되어 DB의 전체 크기가 커짐
	 - 일반적으로 DB의 10% 정도 추가 공간이 필요하게 됨
	 처음 인덱스를 생성하는데 시간이 많이 소요될 수 있음(기존 데이터가 있을 경우)
	 데이터의 변경 작업(insert, update, delete)이 자주 일어날 경우 오히려 성능이 나빠질 수도 있음
	 검색 결과가 너무 많이 나오는 컬럼은 인덱스를 장착하는 것이 오히려 느려지게 됨

 - 인덱스는 클러스터 인덱스(clustered index)와 보조 인덱스(secondary index)로 나뉨
 	보조 인덱스는 비클러스터 인덱스(clustered index)라고도 함

 - 클러스터 인덱스는 테이블당 하나만 생성이 가능하며, 보조 인덱스는 여러 개를 생성할 수 있음
 	클러스터 인덱스는 거의 primary key와 동일한 의미로 사용됨
	- show index from 테이블명 쿼리로 확인 가능
	기본적으로 테이블의 데이터들은 primary key로 지정된 컬럼의 값에 따라 오름차순 정렬됨

 - 보조 인덱스는 특정 컬럼에 unique 제약조건을 걸면 생성됨(여러 개 생성 가능)
 	보조 인덱스가 걸린 컬럼에 not null 제약조건을 추가하면 자동으로 클러스터인덱스로 지정됨
	- 단, primary key가 없을 경우에만 가능
	보조 인덱스가 있어도 정렬은 여전히 primary key를 기준으로 정렬됨

인덱스를 생성하거나 생성하지 않아야 하는 경우
 - where 절에서 조건으로 자주 사용되는 컬럼에는 인덱스를 걸어주는 것이 좋음
 	단, 자주 사용되어야 하며 검색 결과가 적을 수록 효과가 높음

 - 데이터의 중복도가 높은 컬럼은 인덱스를 생성해도 큰 효과가 없음

 - 외래키(FK)를 지정한 컬럼에는 인덱스가 자동으로 생성됨

 - join의 결합조건에 자주 사용되는 컬럼에는 인덱스를 생성해 주는 것이 좋음

 - insert/update/delete가 얼마나 자주 일어나는지 고려해야 함
 	자주 일어나면 인덱스를 생성하는 것이 오히려 속도저하를 가져올 수 있음

 - 클러스터 인덱스가 아예 없는 것이 좋은 경우도 있음
	PK를 지정하지 않고 보조 인덱스에도 not null을 지정하지 않으면 클러스터 인덱스가 없는 상태로 테이블이 생성됨
	insert/update/delete가 자주 일어나는 테이블은 PK가 아예 없는 것이 나을 수 있음
	예 이벤트 진행 시 갑자기 회원이 몰리는 상황 등을 의미
	PK 대신 일렴번호(auto_increment)를 지정하는 경우도 많음

인덱스 생섯 문법
creat index 인덱스명 on 테이블명(인덱스를 장착할 컬럼명);

인덱스 삭제 문법
drop index 인덱스명 on 테이블명;